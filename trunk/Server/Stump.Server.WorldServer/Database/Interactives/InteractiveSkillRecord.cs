using System;
using System.Data.Entity.ModelConfiguration;
using Stump.ORM;
using Stump.ORM.SubSonic.SQLGeneration.Schema;
using Stump.Server.WorldServer.Game.Actors.RolePlay.Characters;
using Stump.Server.WorldServer.Game.Conditions;
using Stump.Server.WorldServer.Game.Interactives;
using Stump.Server.WorldServer.Game.Interactives.Skills;
using Stump.Server.WorldServer.Game.Maps.Cells;

namespace Stump.Server.WorldServer.Database
{
    public class InteractiveSkillRelator
    {
        public static string FetchQuery = "SELECT * FROM interactives_skills";

        public InteractiveSkillRecord Map(InteractiveSkillRecord record)
        {

        }
    }

    [TableName("interactives_skills")]
    public class InteractiveSkillRecord : IAutoGeneratedRecord
    {
        public const int DEFAULT_TEMPLATE = 184;

        private InteractiveSkillRecord()
        {

        }

        private int? m_customTemplateId;
        private InteractiveSkillTemplate m_template;

        public int Id
        {
            get;
            set;
        }

        public string Type
        {
            get;
            set;
        }

        public int? CustomTemplateId
        {
            get { return m_customTemplateId; }
            set
            {
                m_customTemplateId = value;
                m_template = null;
            }
        }

        protected virtual int GenericTemplateId // determin the name
        {
            get { return DEFAULT_TEMPLATE; }
        }

        [Ignore]
        public virtual InteractiveSkillTemplate Template
        {
            get
            {
                return m_template ??
                       (m_template =
                        InteractiveManager.Instance.GetSkillTemplate(CustomTemplateId.HasValue
                                                                         ? CustomTemplateId.Value
                                                                         : GenericTemplateId));
            }
        }

        #region Condition

        public string Condition
        {
            get;
            set;
        }
        private ConditionExpression m_conditionExpression;

        [Ignore]
        public ConditionExpression ConditionExpression
        {
            get
            {
                if (string.IsNullOrEmpty(Condition) || Condition == "null")
                    return null;

                return m_conditionExpression ?? ( m_conditionExpression = ConditionExpression.Parse(Condition) );
            }
            set
            {
                m_conditionExpression = value;
                Condition = value.ToString();
            }
        }

        public bool IsConditionFilled(Character character)
        {
            return ConditionExpression == null || ConditionExpression.Eval(character);
        }


        #endregion

        #region Parameters

        public string Parameter0
        {
            get;
            set;
        }

        public string Parameter1
        {
            get;
            set;
        }

        public string Parameter2
        {
            get;
            set;
        }

        public string Parameter3
        {
            get;
            set;
        }

        public string Parameter4
        {
            get;
            set;
        }

        /// <summary>
        /// Comma separated value
        /// </summary>
        public string AdditionalParameters
        {
            get;
            set;
        }

        public T GetParameter<T>(uint parameter, bool defaultIfEmpty=false)
            where T : IConvertible
        {
            if (parameter <= 4)
            {
                switch (parameter)
                {
                    case 0:
                        return GetParameterInteral<T>(parameter, Parameter0, defaultIfEmpty);
                    case 1:
                        return GetParameterInteral<T>(parameter, Parameter1, defaultIfEmpty);
                    case 2:
                        return GetParameterInteral<T>(parameter, Parameter2, defaultIfEmpty);
                    case 3:
                        return GetParameterInteral<T>(parameter, Parameter3, defaultIfEmpty);
                    case 4:
                        return GetParameterInteral<T>(parameter, Parameter4, defaultIfEmpty);
                }
            }

            if (string.IsNullOrEmpty(AdditionalParameters))
            {
                if (defaultIfEmpty)
                    return default(T); 
                    
                throw new Exception(string.Format("Parameter {0} is empty, cannot be converted to {1}", parameter, typeof(T)));
            }

            var split = AdditionalParameters.Split(',');

            if (split.Length <= parameter - 5)
            {
                if (defaultIfEmpty)
                    return default(T);

                throw new Exception(string.Format("Parameter {0} is empty, cannot be converted to {1}", parameter, typeof(T)));
            }

            return (T)Convert.ChangeType(split[parameter - 5], typeof(T));
        }

        private T GetParameterInteral<T>(uint parameterNum, string parameterStr, bool defaultIfEmpty)
        {
            if (string.IsNullOrEmpty(parameterStr))
            {
                if (defaultIfEmpty)
                    return default(T);

                throw new Exception(string.Format("Parameter {0} is empty, cannot be converted to {1}", parameterNum, typeof (T)));
            }

            return (T)Convert.ChangeType(parameterStr, typeof(T));
        }

        #endregion

        public virtual Skill GenerateSkill(int id, InteractiveObject interactiveObject)
        {
            throw new NotImplementedException("Must be override");
        }
    }
}